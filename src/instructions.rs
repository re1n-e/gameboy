pub enum AddrMode {
    AmImp,
    AmRD16,
    AmRr,
    AmMrr,
    AmR,
    AmRD8,
    AmRMr,
    AmRhli,
    AmRhld,
    AmHlir,
    AmHldr,
    AmRa8,
    AmA8r,
    AmHlspr,
    AmD16,
    AmD8,
    AmD16r,
    AmMrd8,
    AmMr,
    AmA16r,
    AmRa16,
}

pub enum RegType {
    RtNone,
    RtA,
    RtF,
    RtB,
    RtC,
    RtD,
    RtE,
    RtH,
    RtL,
    RtAf,
    RtBc,
    RtDe,
    RtHl,
    RtSp,
    RtPc,
}

pub enum InType {
    InNone,
    InNop,
    InLd,
    InInc,
    InDec,
    InRlca,
    InAdd,
    InRrca,
    InStop,
    InRla,
    InJr,
    InRra,
    InDaa,
    InCpl,
    InScf,
    InCcf,
    InHalt,
    InAdc,
    InSub,
    InSbc,
    InAnd,
    InXor,
    InOr,
    InCp,
    InPop,
    InJp,
    InPush,
    InRet,
    InCb,
    InCall,
    InReti,
    InLdh,
    InJphl,
    InDi,
    InEi,
    InRst,
    InErr,
    //CB instructions...
    InRlc,
    InRrc,
    InRl,
    InRr,
    InSla,
    InSra,
    InSwap,
    InSrl,
    InBit,
    InRes,
    InSet,
}

pub enum CondType {
    CtNone,
    CtNz,
    CtZ,
    CtNc,
    CtC,
}

pub struct Instruction {
    pub type_in: InType,
    pub mode: AddrMode,
    pub reg_1: RegType,
    pub reg_2: RegType,
    pub cond: CondType,
    pub param: u8,
}

pub fn instruction_by_opcode(opcode: u8) -> Option<Instruction> {
    match opcode {
        0x00 => Some(Instruction {
            type_in: InType::InNop,
            mode: AddrMode::AmImp,
            reg_1: RegType::RtNone,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        0x05 => Some(Instruction {
            type_in: InType::InDec,
            mode: AddrMode::AmR,
            reg_1: RegType::RtB,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        0x0E => Some(Instruction {
            type_in: InType::InLd,
            mode: AddrMode::AmRD8,
            reg_1: RegType::RtC,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        0xAF => Some(Instruction {
            type_in: InType::InXor,
            mode: AddrMode::AmR,
            reg_1: RegType::RtA,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        0xC3 => Some(Instruction {
            type_in: InType::InJp,
            mode: AddrMode::AmD16,
            reg_1: RegType::RtNone,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        0xF3 => Some(Instruction {
            type_in: InType::InDi,
            mode: AddrMode::AmImp,
            reg_1: RegType::RtNone,
            reg_2: RegType::RtNone,
            cond: CondType::CtNone,
            param: 0,
        }),
        _ => panic!("Unknown Opcode: {:02X}", opcode),  // Only panic here
    }
}

const INST_LOOKUP: [&str; 48] = [
    "<NONE>",
    "NOP",
    "LD",
    "INC",
    "DEC",
    "RLCA",
    "ADD",
    "RRCA",
    "STOP",
    "RLA",
    "JR",
    "RRA",
    "DAA",
    "CPL",
    "SCF",
    "CCF",
    "HALT",
    "ADC",
    "SUB",
    "SBC",
    "AND",
    "XOR",
    "OR",
    "CP",
    "POP",
    "JP",
    "PUSH",
    "RET",
    "CB",
    "CALL",
    "RETI",
    "LDH",
    "JPHL",
    "DI",
    "EI",
    "RST",
    "IN_ERR",
    "IN_RLC", 
    "IN_RRC",
    "IN_RL", 
    "IN_RR",
    "IN_SLA", 
    "IN_SRA",
    "IN_SWAP", 
    "IN_SRL",
    "IN_BIT", 
    "IN_RES", 
    "IN_SET"
];

// Function to lookup the instruction name based on `InType`
pub fn inst_name(t: &InType) -> &'static str {
    match t {
        InType::InNone => INST_LOOKUP[0],
        InType::InNop => INST_LOOKUP[1],
        InType::InLd => INST_LOOKUP[2],
        InType::InInc => INST_LOOKUP[3],
        InType::InDec => INST_LOOKUP[4],
        InType::InRlca => INST_LOOKUP[5],
        InType::InAdd => INST_LOOKUP[6],
        InType::InRrca => INST_LOOKUP[7],
        InType::InStop => INST_LOOKUP[8],
        InType::InRla => INST_LOOKUP[9],
        InType::InJr => INST_LOOKUP[10],
        InType::InRra => INST_LOOKUP[11],
        InType::InDaa => INST_LOOKUP[12],
        InType::InCpl => INST_LOOKUP[13],
        InType::InScf => INST_LOOKUP[14],
        InType::InCcf => INST_LOOKUP[15],
        InType::InHalt => INST_LOOKUP[16],
        InType::InAdc => INST_LOOKUP[17],
        InType::InSub => INST_LOOKUP[18],
        InType::InSbc => INST_LOOKUP[19],
        InType::InAnd => INST_LOOKUP[20],
        InType::InXor => INST_LOOKUP[21],
        InType::InOr => INST_LOOKUP[22],
        InType::InCp => INST_LOOKUP[23],
        InType::InPop => INST_LOOKUP[24],
        InType::InJp => INST_LOOKUP[25],
        InType::InPush => INST_LOOKUP[26],
        InType::InRet => INST_LOOKUP[27],
        InType::InCb => INST_LOOKUP[28],
        InType::InCall => INST_LOOKUP[29],
        InType::InReti => INST_LOOKUP[30],
        InType::InLdh => INST_LOOKUP[31],
        InType::InJphl => INST_LOOKUP[32],
        InType::InDi => INST_LOOKUP[33],
        InType::InEi => INST_LOOKUP[34],
        InType::InRst => INST_LOOKUP[35],
        InType::InErr => INST_LOOKUP[36],
        InType::InRlc => INST_LOOKUP[37],
        InType::InRrc => INST_LOOKUP[38],
        InType::InRl => INST_LOOKUP[39],
        InType::InRr => INST_LOOKUP[40],
        InType::InSla => INST_LOOKUP[41],
        InType::InSra => INST_LOOKUP[42],
        InType::InSwap => INST_LOOKUP[43],
        InType::InSrl => INST_LOOKUP[44],
        InType::InBit => INST_LOOKUP[45],
        InType::InRes => INST_LOOKUP[46],
        InType::InSet => INST_LOOKUP[47],
    }
}
